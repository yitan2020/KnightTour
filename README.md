# KnightTour
Introduction
This application simulates the chess piece knight’s move around an empty chessboard. The knight moves on the chess board in L-shape and can only touch each square once. The round terminates when the knight has no available square to land. There are two strategies to proceed the knight’s move. One strategy is the knight randomly picks up the available move to tour the chess board, which is called non-intelligent strategy; The other strategy is each square on the chess board is labeled with the level of accessibility, which the harder to access, the lower the level is labeled, the knight chooses to reach the squares labeled lower level firstly and then access the higher level squares, which is called the intelligent strategy.
There is a user interface to interact with user to select which version(strategy) to proceed, appoint a starting point or use default starting point (0,0) and request the number of rounds would like to run.
If the number of rounds is equal to 1, the detailed steps that the knight goes through will be displayed on the right side of interface. If the number of rounds is more than 1, the result statics including the average squares the knight reaches each round and the standard deviation will be displayed.

Algorithm Explanation
Non-intelligent Method
Starting from any square, the knight has 8 potential ways to move and calculate the coordinates of the 8 potential squares that the knight may land. Then each of these 8 potential squares is validated based on two conditions – one is the coordinate X and Y must be with the chessboard boundary which is the value should be between 0 and 7; the other condition is the square should never be touched by the knight. An 8*8 array is created to save the coordinates of the touched square. For example, when the square [7,0] with rate value 2 has not been touched yet, array[7,0] is still equal 0. After the knight lands to square[7,0] on the 14th move, the value of array[7,0] will be set to 14. Hence, if an element of the array is still equal to 0, it means the square which the coordinate X and Y are equal to the index of that element of array has not been touched by the knight yet. Once the 8 potential squares are checked, the valid squares will be considered as possible moves. It will randomly choose one of the possible moves to proceed and then the knight lands on the new square.
It keeps repeating to find the potential squares, validating each square, randomly pick a validated square and land on the new square until there is no valid squares to land.
Intelligent Method
The intelligent method is the same as non-intelligent method for most parts of the process except the way of selecting a possible move. Each square on the chessboard is labeled a rate level based on the accessibility. When the possible moves are found, it will compare the rate level of these possible moves and pick up the one with the lowest rate level to proceed and land on that square. If there are ties among the squares labeled with lowest rate level, it will randomly pick one from the tied squares.
To be more specific, the process of selecting a possible move is divided into three steps. The first step is to find the minimum rate level in the possible moves. And then loop through the list of the possible moves and check the occurrence of the minimum rate level and store all the squares with the minimum rate level to a list. Lastly, randomly pick an index of the square in that list.

Data Structure
List
All the possible moves (the validated squares) are stored in the Square List List<Square> possibleMoves. The main reason to use list instead of array is the size of list is unknow. The number of possible moves is unknow until finishing the validation so it’s impossible to define an array with a fixed size.
Another Square List named minList is used to store the squares which owns the lowest rate level. Since the number of elements in the list is unknow, the list structure is used.
Furthermore, as the elements in the list have the same data type so the generics collection was considered to improve the efficiency.
Array
To simulate the chessboard, two int[] array – one named chessboard the other named occupiedSquare are created because it is known to have a fixed size 8*8 as it will store the 64 squares hence 2D array is a good option. The other reason is the manipulation of their data structures will not be needed.
The int[] Record is an 1D integer array used to store the total number of touched squares each round. As the number of rounds is fixed, so the size of the int[] Record is fixed as well.
